/* Plugin generated by AMXX-Studio */ 

#include <amxmodx>
#include <amxmisc>
#include <engine>
#include <fakemeta>
#include <nvault>
#include <hamsandwich>

#define PLUGIN "Timer + Life Transfer"
#define VERSION "0.1"
#define AUTHOR "Dr.FioriGinal.Ro"
#pragma semicolon 1

#define IsPlayer(%1) ( 1 <= %1 <= MAX_PLAYERS ) // 32 sloturi neaparat

new g_TimeS[MAX_PLAYERS+1], g_TimeM[MAX_PLAYERS+1];
new StatusText;
new bool:used[MAX_PLAYERS+1];
new concurs, queue[MAX_PLAYERS+1][32], queue_values[MAX_PLAYERS+1], queue_index[MAX_PLAYERS+1], contor, bool:Error;

const OFFSET_CSTEAMS = 114;

public plugin_init() {
	register_plugin(PLUGIN, VERSION, AUTHOR);
	register_clcmd( "say", "clcmdsay_transfer_life" );
	register_clcmd( "say_team", "clcmdsay_transfer_life" );	
	register_clcmd( "life", "transfer_life" );
	register_clcmd( "lifemenu", "transfer_life_menu" );
	RegisterHam(Ham_Spawn, "player", "Fwd_PlayerSpawn_Post", 1);
	RegisterHam(Ham_Killed, "player", "Fwd_PlayerKilled_Pre", 0);
	register_event("ResetHUD", "newRound", "b");
	StatusText = get_user_msgid("StatusText");
	
	register_forward(FM_PlayerPreThink, "fwdPlayerPreThink");
}
 
public client_disconnect(id)
	{
	if(task_exists(id + 5551))
		remove_task(id + 5551);
		
	new aux[32], ip[32];
	
	get_user_ip(id, ip, charsmax(ip), 1);
	
	for(new i = 1; i <= contor; ++i)
	{
		get_user_ip(queue_index[i], aux, charsmax(aux), 1);
		if ( equal(aux, ip) )
		{
			queue_values[queue_index[i]] = 0;
			queue_index[i] = 0;
			Sort();
			--contor;
			break;
		}
	}
}

public newRound() 
{
	new Players[MAX_PLAYERS], PlayersNum;
	
	get_players(Players, PlayersNum, "ch");
	
	for (new i = 0; i < PlayersNum; ++i)
	{
		used[Players[i]] = false;
	}
}

public Fwd_PlayerSpawn_Post(const id)
{
	if( fm_get_user_team(id) == 2 )
	{
		g_TimeS[id] = 0;
		g_TimeM[id] = 0;
		if(task_exists(id + 5551))
			remove_task(id + 5551);
		set_task( 1.0, "Timer",id + 5551, _, _, "b" );
	}
	else
	{
		if(task_exists(id + 5551))
			remove_task(id + 5551);
		g_TimeS[id] = 0;
		g_TimeM[id] = 0;
	}
}

public Timer(id)
{
	id -= 5551;
	g_TimeS[id]++;
	if( g_TimeS[id] == 60)
	{
		g_TimeS[id] = 0;
		g_TimeM[id]++;
	}
       
	new target, body;
	get_user_aiming( id, target, body, 9999);
       
	if (!IsPlayer(target))
	{
		new sSMsg[32];
		format(sSMsg, charsmax(sSMsg), "Your time: %02d:%02d", g_TimeM[id], g_TimeS[id]);
		message_begin(MSG_ONE, StatusText, {0,0,0}, id);
		write_byte(0);
		write_string(sSMsg);
		message_end();
	}
}

public Fwd_PlayerKilled_Pre(victim, attacker, shouldgib)
{
	//client_print(0, print_chat, "debug 1");
	if(fm_get_user_team(victim) == 1 && fm_get_user_team(attacker) == 2)
	{
		//client_print(0, print_chat, "debug 2");
		if( (g_TimeS[attacker] > 30 || g_TimeM[attacker] != 0) && !used[attacker])
		{
			
			//client_print(0, print_chat, "debug 3");
			if ( concurs && !(get_user_flags(attacker) & ADMIN_KICK) )
			{
				//client_print(0, print_chat, "debug 4");
				addInQueue(attacker);
				printInChat();
			}
			else
			{
				//client_print(0, print_chat, "debug 4");
				if( g_TimeM[attacker] >= 1 )
					client_print_color(0, print_team_red, "^1 [Dr.FioriGinal.Ro] ^4%s^3 a ucis teroristul ^4%s^3 în %d minut%s și %d secund%s",szName(attacker) ,szName(victim), g_TimeM[attacker], ( (g_TimeM[attacker]>1 || g_TimeM[attacker] == 0)?"e":""), g_TimeS[attacker], ((g_TimeS[attacker]>1 || g_TimeS[attacker] == 0)?"e":""));
				else    
					client_print_color(0, print_team_red, "^1 [Dr.FioriGinal.Ro] ^4%s^3 a ucis teroristul ^4%s^3 în %d secund%s",szName(attacker), szName(victim), g_TimeS[attacker], ((g_TimeS[attacker]>1 || g_TimeS[attacker] == 0)?"e":"")); 
			}
		}
	}
	return HAM_IGNORED;
}

addInQueue(id)
{
	new ip[32], aux[32];
	get_user_ip(id, ip, charsmax(ip), 1);
	
	for(new i = 1; i <= contor; ++i)
	{
		get_user_ip(queue_index[i], aux, charsmax(aux), 1);
		if ( equal(aux, ip) )
		{
			++queue_values[i];
			Sort();
			return;
		}
		//client_print(0, print_chat, "%s - %s", aux, ip);
	}
	
	copy(queue[++contor], charsmax(queue[]), ip);
	++queue_values[contor];
	queue_index[contor] = id;
	
	
	Sort();
}

Sort()
{
	new aux, auxbuffer[32];
	for(new i = 1; i <= contor; ++i)
	{
		for(new j = i; j <= contor; ++j)
		{
			if ( queue_values[i] < queue_values[j] )
			{
				aux = queue_values[i];
				queue_values[i] = queue_values[j];
				queue_values[j] = aux;
				aux = queue_index[i];
				queue_index[i] = queue_index[j];
				queue_index[j] = aux;
				copy(auxbuffer, charsmax(auxbuffer), queue[i]);
				copy(queue[i], charsmax(queue[]), queue[j]);
				copy(queue[j], charsmax(queue[]), auxbuffer);
			}
		}
	}
}

getName(ip[], bool:error = false)
{
	new name[MAX_NAME_LENGTH], aux[32];
	
	for(new i = 1; i <= get_playersnum(); ++i)
	{
		get_user_ip(queue_index[i], aux, charsmax(aux), 1);
		if ( equal(aux, ip) )
		{
			get_user_name(queue_index[i], name, charsmax(name));
			return name;
		}
	}
	
	if ( error )
	{
		Error = true;
		return name;
	}
			
	for (new i = 1; i <= contor; ++i)
	{
		if ( equal(queue[i], ip) )
		{
			queue_values[i] = 0;
			break;
		}
	}
	
	Sort();
	--contor;
	
	return getName(ip, true);
}

printInChat(id = 0)
{
	new text[192];
	Error = false;
	switch ( contor )
	{
		case 0:  formatex(text, charsmax(text), "^4[^3Concurs^4]^1 Clasament : Nici un jucător nu a înscris încă.");
		case 1:  formatex(text, charsmax(text), "^4[^3Concurs^4]^1 Clasament : ^4%s^1 este singurul jucător care a punctat ! (^4%d^1 punct%s)", getName(queue[1]), queue_values[1], queue_values[1] == 1 ? "" : "e");
		case 2:  formatex(text, charsmax(text), "^4[^3Concurs^4]^1 Clasament : 1.^4%s^1 (^4%d^1 punct%s), 2.^4%s^1 (^4%d^1 punct%s)", getName(queue[1]), queue_values[1], queue_values[1] == 1 ? "" : "e", getName(queue[2]), queue_values[2], queue_values[2] == 1 ? "" : "e");
		default: formatex(text, charsmax(text), "^4[^3Concurs^4]^1 Clasament : 1.^4%s^1 (^4%d^1 punct%s), 2.^4%s^1 (^4%d^1 punct%s), 3.^4%s^1 (^4%d^1 punct%s)", getName(queue[1]), queue_values[1], queue_values[1] == 1 ? "" : "e", getName(queue[2]), queue_values[2], queue_values[2] == 1 ? "" : "e", getName(queue[3]), queue_values[3], queue_values[3] == 1 ? "" : "e");
	}
	if ( Error )
	{
		printInChat(id);
	}
	else
	{
		client_print_color(id, print_team_red, "%s", text);
	}
}

public clcmdsay_transfer_life( id )
{
	static args[ 192 ], command[ 192 ];
	read_args( args, charsmax( args ) );
	
	if( !args[ 0 ] )
		return PLUGIN_CONTINUE;
	
	remove_quotes( args[ 0 ] );
	
	new const lifeIdent[] = "!life", concursIdent[] = "!concurs", lifemenuIdent[] = "!lifemenu", scorIdent[] = "!scor";
	
	if( equal(args, scorIdent, charsmax(scorIdent)) && concurs)
	{
		printInChat(id);
	}
	
	if( equal(args, lifeIdent, charsmax(lifeIdent)) && !concurs )
	{
		replace(args, charsmax(args), "!", "");
		formatex(command, charsmax(command), "%s", args);
		client_cmd(id, command);
	}
	
	if( equal(args, concursIdent, charsmax(concursIdent)) && get_user_flags(id) & ADMIN_IMMUNITY  )
	{
		if ( concurs )
		{
			concurs = false;
			client_print_color(0, print_team_red, "^4[^3Concurs^4]^1 Modul concurs a fost dezactivat");
		}
		else
		{
			concurs = true;
			client_print_color(0, print_team_red, "^4[^3Concurs^4]^1 Modul concurs a fost activat");
		}
	}
	
	if( equal(args, lifemenuIdent, charsmax(lifemenuIdent)) && !concurs )
	{
		transfer_life_menu(id);
	}
	
	return PLUGIN_CONTINUE;
}

public transfer_life( id )
	{
	if( !is_user_alive( id ) )
		{
		console_print( id, "[Transfer Life] Trebuie sa fi in viata!" );
		return PLUGIN_HANDLED;
	}
	
	new arg[ 32 ];
	new origin[ 3 ], name[ 32 ], target_name[ 32 ];
	
	read_argv( 1, arg, 31 );
	new target = cmd_target( id, arg, 0 );
	if( !target )
		{
		console_print( id, "[Transfer Life] Jucatorul NU se afla pe server!" );
		return PLUGIN_HANDLED;
	}
	
	if( is_user_alive( target ) )
		{
		console_print( id, "[Transfer Life] Jucatorul este deja in viata!" );
		return PLUGIN_HANDLED;
	}
	
	if( get_user_team( id ) != get_user_team( target ) )
		{
		console_print( id, "[Transfer Life] Jucatorul trebuie sa fie in aceeasi echipa cu tine!" );
		return PLUGIN_HANDLED;
	}
	new health;
	health = get_user_health( id );
	
	ExecuteHamB( Ham_CS_RoundRespawn, target );
	fm_set_user_health( target, health );
	
	user_silentkill( id );
	
	get_user_origin( id, origin, 0 );
	origin[ 2 ] += 20;
	
	fm_set_user_origin( target, origin );
	fm_strip_user_weapons( target );
	fm_give_item( target, "weapon_knife" );
	used[target] = true;
	
	get_user_name( id, name, 31 );
	get_user_name( target, target_name, 31 );
	client_print( 0, print_chat, "[Transfer Life] %s i-a dat viața lui %s .", name, target_name );
	
	return PLUGIN_HANDLED;
}

public transfer_life_menu( id )
{
	if( !is_user_alive( id ) )
	{
		client_print( id, print_chat, "[Transfer Life] Meniul nu poate fi deschis!" );
		return;
	}
	
	new menu = menu_create( "\rTransfer Life Menu:", "menu_handler" );
	
	new players[ 32 ], pnum, tempid,
	name_players[ 32 ], tempid2[ 10 ];
	
	get_players(players, pnum);
	for( new i; i < pnum; i++ )
		{
		tempid = players[ i ];
		
		if( get_user_team( id ) != get_user_team( tempid ) )
			continue;
		if( is_user_alive( tempid ) )
			continue;
		
		get_user_name( tempid, name_players, 31 );
		num_to_str( tempid, tempid2, 9 );
		
		menu_additem( menu, name_players, tempid2, 0 );
	}
	
	menu_display( id, menu, 0 );
}

public menu_handler( id, menu, item )
	{
	if( item == MENU_EXIT )
		{
		menu_destroy( menu );
		return PLUGIN_HANDLED;
	}
	
	new data[ 6 ], name_menu[ 64 ], access, callback, name_target[ 32 ];
	menu_item_getinfo( menu, item, access, data, 5, name_menu, 63, callback );
	
	new tempid = str_to_num( data );
	
	new name_userid = get_user_userid(tempid);
	get_user_name( tempid, name_target, 31 );
	client_cmd( id, "life #%d", name_userid );
	
	menu_destroy( menu );
	return PLUGIN_HANDLED;
}

//fakemeta_util by VEN
stock fm_entity_set_origin( index, const Float:origin[ 3 ] ) 
	{
	new Float:mins[ 3 ], Float:maxs[ 3 ];
	pev( index, pev_mins, mins );
	pev( index, pev_maxs, maxs );
	engfunc( EngFunc_SetSize, index, mins, maxs );
	
	return engfunc( EngFunc_SetOrigin, index, origin );
}

stock fm_set_user_origin( index, origin[ 3 ] ) 
	{
	new Float:orig[ 3 ];
	IVecFVec( origin, orig );
	
	return fm_entity_set_origin( index, orig );
}

stock fm_set_user_health( index, health ) 
	{
	health > 0
	? set_pev( index, pev_health, float( health ) ) 
	: dllfunc( DLLFunc_ClientKill, index );
	
	return 1;
}

stock fm_set_user_frags( index, frags ) 
	{ 
	set_pev( index, pev_frags, float( frags ) );
	
	return 1;
}

stock fm_strip_user_weapons( id )
{
	static ent;
	ent = engfunc( EngFunc_CreateNamedEntity, engfunc( EngFunc_AllocString, "player_weaponstrip" ) );
	if( !pev_valid( ent ) ) 
		return;
	
	dllfunc( DLLFunc_Spawn, ent );
	dllfunc( DLLFunc_Use, ent, id );
	engfunc( EngFunc_RemoveEntity, ent );
} 

stock fm_give_item( id, const item[] )
{
	static ent;
	ent = engfunc( EngFunc_CreateNamedEntity, engfunc(EngFunc_AllocString, item ) );
	if( !pev_valid( ent ) ) 
		return;
	
	static Float:originF[ 3 ];
	pev( id, pev_origin, originF );
	set_pev( ent, pev_origin, originF );
	set_pev( ent, pev_spawnflags, pev( ent, pev_spawnflags ) | SF_NORESPAWN );
	dllfunc( DLLFunc_Spawn, ent );
	
	static save;
	save = pev( ent, pev_solid );
	dllfunc( DLLFunc_Touch, ent, id );
	if( pev( ent, pev_solid ) != save )
		return;
	
	engfunc( EngFunc_RemoveEntity, ent );
}

stock szName(id)
{
	new sz_Name[32];
	
	get_user_name(id, sz_Name, charsmax(sz_Name));
	
	return sz_Name;
}

stock fm_get_user_team( id )
{
	return get_pdata_int( id, OFFSET_CSTEAMS );
}
