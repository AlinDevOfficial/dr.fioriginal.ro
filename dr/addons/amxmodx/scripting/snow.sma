/* Plugin generated by AMXX-Studio */

	#include < amxmodx >
	#include < fakemeta >
	#include < engine >
	#include < xs >
	
	
	new const
		PLUGIN_NAME[ ] 		= "Realistic Snow",
		PLUGIN_VERSION[ ] 	= "0.4.2b";
		
	
	#define	TASKID_FOG	1337
	#define TASKID_WIND	7331
		
		
	/* Thanks to joropito for his SuperSpawns */
	#define SS_VERSION	"1.0"
	#define SS_MIN_DISTANCE	250.0
	#define SS_MAX_LOOPS	100000
	
	new Array:g_vecSsOrigins;
	new Array:g_vecSsSpawns;
	new Array:g_vecSsUsed;
	new Float:g_flSsMinDist;
	new g_iSsTime;
	
	new const g_szStarts[][] =
	{
		"info_player_start",
		"info_player_deathmatch"
	};
	
	new const Float:g_flOffsets[] =
	{
		3500.0,
		3500.0,
		1500.0
	};
	/* End of SuperSpawns */
	
	new const g_szSound[ ] = "misc/rs_wind.wav";
	
	new g_iCvarSound;
	new g_iCvarSky;
	new g_iCvarLight;
	new g_iCvarFog;
	new g_iCvarSnowType;
	
	new g_iSprite;
	
	new Array:g_vecOrigins;
	new g_iOrigins = 0;
	
	new g_iMagicEntity;
	
public plugin_precache( )
{	
	// We register plugin info and the cvars here because it's a must!
	register_plugin( PLUGIN_NAME, PLUGIN_VERSION, "Askhanar" );	

	g_iCvarSound = register_cvar( "rs_sound", "1" );
	g_iCvarSky = register_cvar( "rs_sky", "1" );
	g_iCvarLight = register_cvar( "rs_light", "1" );
	g_iCvarFog = register_cvar( "rs_fog", "1" );
	g_iCvarSnowType = register_cvar( "rs_type", "3" );
	
	
	// Precache our wind sound.
	precache_sound( g_szSound );
		
	//Precache our snow .spr
	g_iSprite = precache_model( "sprites/snow1.spr" );
	
	
	// Let's put a random snow sky if the cvar allows us to.
	if( get_pcvar_num( g_iCvarSky) )
		set_cvar_string( "sv_skyname", random_num( 0, 1 ) == 1 ? "snow" : "snowlake_" );
	
	// We need to make the snow look cooler.. so let's make the map darker.. if the cvar allows us to.
	if( get_pcvar_num( g_iCvarLight ) )
		set_lights( "d" );
}
				
public plugin_init( )
{
	
	// We make sure to remove anoying entities..
	remove_entity_name( "env_fog" );
	remove_entity_name( "env_rain" );
	remove_entity_name( "env_snow" );
	
	// Prepare some stuffs
	g_vecOrigins = ArrayCreate( 3, 1 );
	SsInit( 200.0 );
	SsScan( );
	SsDump( );
	
	// Set a task to play sound..
	set_task( 35.0, "task_PlayWind", TASKID_WIND, _, _, "b", 0 );
	
	// Create our MagicEntity. ( snow's brain.. )
	CreateEntity:
	
	new iEnt;
	iEnt  = engfunc( EngFunc_CreateNamedEntity, engfunc( EngFunc_AllocString, "info_target" ) );
	if( !pev_valid( iEnt ) || !iEnt )
		goto CreateEntity;
	
	set_pev( iEnt, pev_classname, "Askhanar's_MagicEntity" );
	set_pev( iEnt, pev_nextthink, get_gametime(  ) + 1.0 );
	
	register_forward( FM_Think, "fwd_MagicEntityThink" );
	g_iMagicEntity = iEnt;
	
	
	
}

public task_PlayWind( )
	if( get_pcvar_num( g_iCvarSound ) )
	{
		client_cmd( 0, "spk %s", g_szSound );
	}

public client_putinserver( id )
{
	if( is_user_bot( id ) || is_user_hltv( id ) )
		return;
		
	if( get_pcvar_num( g_iCvarFog ) )
		if( !task_exists( id + TASKID_FOG ) )
			set_task( 3.0, "task_MakeFogToPlayer", id + TASKID_FOG );
		
}

public task_MakeFogToPlayer( id )
{
	
	id -= TASKID_FOG;
	if( !is_user_connected( id ) )
		return;
		
	MakeFog( id, 255, 255, 255, 111, 18, 3, 58 );
	
}

public fwd_MagicEntityThink( iEnt )
{
	set_pev( iEnt, pev_nextthink, get_gametime( ) + 3.1 );
	
	static iSnowType;
	iSnowType = clamp( get_pcvar_num( g_iCvarSnowType ), 0, 3 );

	if( iEnt != g_iMagicEntity || !pev_valid( iEnt ) || !iSnowType )
		return FMRES_IGNORED;
		
		
		
	static Float:fOrigin[ 3 ], iLocations, iCount;
	//iCount = iSnowType == 1 ? 3 : iSnowType * 2;
	switch( iSnowType )
	{
		case 1:
		{
			iCount = 3;
			iLocations = 20;
		}
		case 2:
		{
			iCount = 5;
			iLocations = 30;
		}
		case 3:
		{
			iCount = 10;
			iLocations = 45;
		}
	}
	
	while( iLocations > 0 )
	{
		ArrayGetArray( g_vecOrigins, random( g_iOrigins ), fOrigin );
		MakeSnow( fOrigin, g_iSprite, iCount, 8, random_num( 5, 10 ), 50, 30 );
		iLocations--;
		
	}
	
	return FMRES_IGNORED;
}

MakeSnow( Float:fOrigin[ 3 ], iSpriteId, iCount, iLife, iScale, iVelocity, iRandomness )
{
	engfunc( EngFunc_MessageBegin, MSG_BROADCAST, SVC_TEMPENTITY, fOrigin, 0 );
	write_byte( TE_SPRITETRAIL ); // TE ID
	engfunc( EngFunc_WriteCoord, fOrigin[ 0 ] ); // x axis
	engfunc( EngFunc_WriteCoord, fOrigin[ 1 ] ); // y axis
	engfunc( EngFunc_WriteCoord, fOrigin[ 2 ] + 40 ); // z axis
	engfunc( EngFunc_WriteCoord, fOrigin[ 0 ] ); // x axis
	engfunc( EngFunc_WriteCoord, fOrigin[ 1 ] ); // y axis
	engfunc( EngFunc_WriteCoord, fOrigin[ 2 ] ); // z axis
	write_short( iSpriteId ); // Sprite Index
	write_byte( iCount ); // Count
	write_byte( iLife ); // Life
	write_byte( iScale ); // Scale
	write_byte( iVelocity  ); // Velocity Along Vector
	write_byte( iRandomness ); // Rendomness of Velocity
	message_end( );
}

MakeFog( id, const iRed, const iGreen, const iBlue, const iSD, const iED, const iD1, const iD2 )
{
	static iMsgIdFog;
	
	message_begin( id == 0 ? MSG_ALL : MSG_ONE, !iMsgIdFog ? ( iMsgIdFog = get_user_msgid( "Fog" ) ) : iMsgIdFog, {0, 0, 0}, id );
	write_byte( iRed );  // R
	write_byte( iGreen );  // G
	write_byte( iBlue );  // B
	write_byte( iSD ); // SD
	write_byte( iED );  // ED
	write_byte( iD1 );   // D1
	write_byte( iD2 );  // D2
	message_end(  );
}


stock Get_Sky_Origin( const Float:vecTarget[ 3 ], Float:vecStart[ 3 ] )
{

	new Float:vecHit[ 3 ];
	vecStart[ 0 ] = vecTarget[ 0 ];
	vecStart[ 1 ] = vecTarget[ 1 ];
	vecStart[ 2 ] = vecTarget[ 2 ] + 5096.0;
	
	while( engfunc( EngFunc_PointContents, vecStart ) != -1 )
	{
		if( vecStart[ 2 ] < vecTarget[ 2 ] + 128.0 )
			break;
			
		vecStart[ 2 ] -= 16.0;
	}
	
	if( vecStart[ 2 ] - vecTarget[ 2 ] <= 196.0 )
		return 0;
		
	xs_vec_copy( vecStart, vecHit );
	vecHit[ 2 ] += 256.0;
	
	new s_TextureName[ 16 ];
	engfunc( EngFunc_TraceTexture, 0, vecStart, vecHit, s_TextureName, charsmax( s_TextureName ) );
	if( !equal( s_TextureName, "sky" ) )
		return 0
	
	vecStart[ 2 ] -= 10.0;
	return 1;
}

/*====================================
=============Super Spawns============*/

public SsInit(Float:mindist)
{
	
	register_cvar("sv_superspawns", SS_VERSION, (FCVAR_SERVER|FCVAR_SPONLY));
	register_concmd("_ss_dump", "SsDump");

	g_flSsMinDist = mindist;
	g_vecSsOrigins = ArrayCreate(3, 1);
	g_vecSsSpawns = ArrayCreate(3, 1);
	g_vecSsUsed = ArrayCreate(3, 1);
}

stock SsClean()
{
	g_flSsMinDist = 0.0;
	ArrayClear(g_vecSsOrigins);
	ArrayClear(g_vecSsSpawns);
	ArrayClear(g_vecSsUsed);
}

stock SsGetOrigin(Float:origin[3])
{
	new Float:data[3], size;
	new ok = 1;

	while((size = ArraySize(g_vecSsOrigins)))
	{
		new idx = random_num(0, size - 1);

		ArrayGetArray(g_vecSsOrigins, idx, origin);

		new used = ArraySize(g_vecSsUsed);
		for(new i = 0; i < used; i++)
		{
			ok = 0;
			ArrayGetArray(g_vecSsUsed, i, data);
			if(get_distance_f(data, origin) >= g_flSsMinDist)
			{
				ok = 1;
				break;
			}
		}

		ArrayDeleteItem(g_vecSsOrigins, idx);
		if(ok)
		{
			ArrayPushArray(g_vecSsUsed, origin);
			return true;
		}
	}
	return false;
}

public SsDump()
{
	new Float:origin[3], Float:fOrigin[ 3 ];
	new count = ArraySize(g_vecSsOrigins);
	server_print("-------------------------------------------------------");

	for(new i = 0; i < count; i++)
	{
		ArrayGetArray(g_vecSsOrigins, i, origin);

		if( Get_Sky_Origin( origin, fOrigin )  )
		{
			ArrayPushArray( g_vecOrigins, fOrigin );
			g_iOrigins++;
		}
	}
/*
	server_print("-------------------------------------------------------");
	server_print("Number of origins: %i", count);
	server_print("Number of good origins: %i", g_iOrigins);
	server_print("Time: %i", g_iSsTime);
	server_print("-------------------------------------------------------");
*/
	
}

public SsScan()
{
	new start, Float:origin[3], starttime;
	starttime = get_systime();
	for(start = 0; start < sizeof(g_szStarts); start++)
	{
		server_print("Searching for %s", g_szStarts[start]);
		new ent;
		if((ent = engfunc(EngFunc_FindEntityByString, ent, "classname", g_szStarts[start])))
		{
			new counter;
			pev(ent, pev_origin, origin);
			ArrayPushArray(g_vecSsSpawns, origin);
			while(counter < SS_MAX_LOOPS)
			{
				counter = GetLocation(origin, counter);
			}
		}
	}
	g_iSsTime = get_systime();
	g_iSsTime -= starttime;
}

GetLocation(Float:start[3], &counter)
{
	new Float:end[3];
	for(new i = 0; i < 3; i++)
	{
		end[i] += random_float(0.0 - g_flOffsets[i], g_flOffsets[i]);
	}

	if(IsValid(start, end))
	{
		start[0] = end[0];
		start[1] = end[1];
		start[2] = end[2];
		ArrayPushArray(g_vecSsOrigins, end);
	}
	counter++;
	return counter;
}

IsValid(Float:start[3], Float:end[3])
{
	SetFloor(end);
	end[2] += 36.0;
	new point = engfunc(EngFunc_PointContents, end);
	if(point == CONTENTS_EMPTY)
	{
		if(CheckPoints(end) && CheckDistance(end) && CheckVisibility(start, end))
		{
			if(!trace_hull(end, HULL_LARGE, -1))
			{
				return true;
			}
		}
	}
	return false;
}

CheckVisibility(Float:start[3], Float:end[3])
{
	new tr;
	engfunc(EngFunc_TraceLine, start, end, IGNORE_GLASS, -1, tr);
	return (get_tr2(tr, TR_pHit) < 0);
}

SetFloor(Float:start[3])
{
	new tr, Float:end[3];
	end[0] = start[0];
	end[1] = start[1];
	end[2] = -99999.9;
	engfunc(EngFunc_TraceLine, start, end, DONT_IGNORE_MONSTERS, -1, tr);
	get_tr2(tr, TR_vecEndPos, start);
}

CheckPoints(Float:origin[3])
{
	new Float:data[3], tr, point;
	data[0] = origin[0];
	data[1] = origin[1];
	data[2] = 99999.9;
	engfunc(EngFunc_TraceLine, origin, data, DONT_IGNORE_MONSTERS, -1, tr);
	get_tr2(tr, TR_vecEndPos, data);
	point = engfunc(EngFunc_PointContents, data);
	if(point == CONTENTS_SKY && get_distance_f(origin, data) < 250.0)
	{
		return false;
	}
	data[2] = -99999.9;
	engfunc(EngFunc_TraceLine, origin, data, DONT_IGNORE_MONSTERS, -1, tr);
	get_tr2(tr, TR_vecEndPos, data);
	point = engfunc(EngFunc_PointContents, data);
	if(point < CONTENTS_SOLID)
		return false;
	
	return true;
}

CheckDistance(Float:origin[3])
{
	new Float:dist, Float:data[3];
	new count = ArraySize(g_vecSsSpawns);
	for(new i = 0; i < count; i++)
	{
		ArrayGetArray(g_vecSsSpawns, i, data);
		dist = get_distance_f(origin, data);
		if(dist < SS_MIN_DISTANCE)
			return false;
	}

	count = ArraySize(g_vecSsOrigins);
	for(new i = 0; i < count; i++)
	{
		ArrayGetArray(g_vecSsOrigins, i, data);
		dist = get_distance_f(origin, data);
		if(dist < SS_MIN_DISTANCE)
			return false;
	}

	return true;
}

/*====================================
=============Super Spawns============*/